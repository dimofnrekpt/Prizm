import { PrizmInvalidDayException } from '../../exceptions/invalid-day.exception';
import { PrizmInvalidMonthException } from '../../exceptions/invalid-month.exception';
import { PrizmInvalidYearException } from '../../exceptions/invalid-year.exception';
import { prizmInRange, prizmNormalizeToIntNumber } from '../../util/math';
import { PRIZM_DATE_FILLER_LENGTH } from './date-fillers';
import { PRIZM_DAYS_IN_WEEK, PRIZM_MIN_DAY, PRIZM_MONTHS_IN_YEAR } from './date-time';
import { PrizmMonth } from './month';
import { PrizmYear } from './year';
import { prizmAssert, prizmPadStart } from '@prizm-ui/core';
// TODO: Localized formatting
/**
 * Immutable date object, consisting of day, month and year
 */
export class PrizmDay extends PrizmMonth {
    constructor(year, month, day) {
        super(year, month);
        this.day = day;
        prizmAssert.assert(PrizmDay.isValidDay(year, month, day), {
            year,
            month,
            day,
        });
    }
    /**
     * Creates {@link PrizmDay} from native {@link Date} based on local time zone
     */
    static fromLocalNativeDate(date) {
        return new PrizmDay(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * Creates {@link PrizmDay} from native {@link Date} using UTC
     */
    static fromUtcNativeDate(date) {
        return new PrizmDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    }
    /**
     * Check validity of year, month and day
     *
     * @param year
     * @param month
     * @param day
     * @return boolean validity
     */
    static isValidDay(year, month, day) {
        return (PrizmMonth.isValidMonth(year, month) &&
            Number.isInteger(day) &&
            prizmInRange(day, PRIZM_MIN_DAY, PrizmMonth.getMonthDaysCount(month, PrizmYear.isLeapYear(year)) + 1));
    }
    /**
     * @deprecated DONT USE IT (will be deleted soon)
     *
     * Calculated day on a calendar grid
     *
     * @param month
     * @param row row in a calendar
     * @param col column in a calendar
     * @return resulting day on these coordinates (could exceed passed month)
     */
    static getDayFromMonthRowCol(month, row, col) {
        prizmAssert.assert(Number.isInteger(row));
        prizmAssert.assert(prizmInRange(row, 0, 6));
        prizmAssert.assert(Number.isInteger(col));
        prizmAssert.assert(prizmInRange(col, 0, PRIZM_DAYS_IN_WEEK));
        let day = row * PRIZM_DAYS_IN_WEEK + col - month.monthStartDaysOffset + 1;
        if (day > month.daysCount) {
            day = day - month.daysCount;
            month = month.append({ month: 1 });
        }
        if (day <= 0) {
            month = month.append({ month: -1 });
            day = month.daysCount + day;
        }
        return new PrizmDay(month.year, month.month, day);
    }
    /**
     * Current day based on local time zone
     */
    static currentLocal() {
        const nativeDate = new Date();
        const year = nativeDate.getFullYear();
        const month = nativeDate.getMonth();
        const day = nativeDate.getDate();
        return new PrizmDay(year, month, day);
    }
    /**
     * Returns current day based on UTC
     */
    static currentUtc() {
        const nativeDate = new Date();
        const year = nativeDate.getUTCFullYear();
        const month = nativeDate.getUTCMonth();
        const day = nativeDate.getUTCDate();
        return new PrizmDay(year, month, day);
    }
    /**
     * Calculates {@link PrizmDay} normalizing year, month and day. {@link NaN} is turned into minimal value.
     *
     * @param year any year value, including invalid
     * @param month any month value, including invalid (months start with 0)
     * @param day any day value, including invalid
     * @return normalized date
     */
    static normalizeOf(year, month, day) {
        const normalizedYear = PrizmYear.normalizeYearPart(year);
        const normalizedMonth = PrizmMonth.normalizeMonthPart(month);
        const normalizedDay = PrizmDay.normalizeDayPart(day, normalizedMonth, normalizedYear);
        return new PrizmDay(normalizedYear, normalizedMonth, normalizedDay);
    }
    static lengthBetween(from, to) {
        return Math.round((to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) / (1000 * 60 * 60 * 24));
    }
    static parseRawDateString(date, dateMode = `DMY`) {
        prizmAssert.assert(date.length === PRIZM_DATE_FILLER_LENGTH, `[parseRawDateString]: wrong date string length`);
        switch (dateMode) {
            case `YMD`:
                return {
                    day: parseInt(date.slice(8, 10), 10),
                    month: parseInt(date.slice(5, 7), 10) - 1,
                    year: parseInt(date.slice(0, 4), 10),
                };
            case `MDY`:
                return {
                    day: parseInt(date.slice(3, 5), 10),
                    month: parseInt(date.slice(0, 2), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
            default:
            case `DMY`:
                return {
                    day: parseInt(date.slice(0, 2), 10),
                    month: parseInt(date.slice(3, 5), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
        }
    }
    // TODO: Move month and year related code corresponding classes
    /**
     * Parsing a string with date with normalization
     *
     * @param rawDate date string
     * @param dateMode date format of the date string (DMY | MDY | YMD)
     * @return normalized date
     */
    static normalizeParse(rawDate, dateMode = `DMY`) {
        const { day, month, year } = this.parseRawDateString(rawDate, dateMode);
        return PrizmDay.normalizeOf(year, month, day);
    }
    /**
     * Parsing a date stringified in a toJSON format
     * @param yearMonthDayString date string in format of YYYY-MM-DD
     * @return date
     * @throws exceptions if any part of the date is invalid
     */
    static jsonParse(yearMonthDayString) {
        const { day, month, year } = this.parseRawDateString(yearMonthDayString, `YMD`);
        if (!PrizmYear.isValidYear(year)) {
            throw new PrizmInvalidYearException(year);
        }
        if (!PrizmMonth.isValidMonth(year, month)) {
            throw new PrizmInvalidMonthException(month);
        }
        if (!Number.isInteger(day) ||
            !prizmInRange(day, PRIZM_MIN_DAY, PrizmMonth.getMonthDaysCount(month, PrizmYear.isLeapYear(year)) + 1)) {
            throw new PrizmInvalidDayException(day);
        }
        return new PrizmDay(year, month, day);
    }
    static normalizeDayPart(day, month, year) {
        prizmAssert.assert(PrizmMonth.isValidMonth(year, month));
        const monthDaysCount = PrizmMonth.getMonthDaysCount(month, PrizmYear.isLeapYear(year));
        return prizmNormalizeToIntNumber(day, 1, monthDaysCount);
    }
    get formattedDayPart() {
        return prizmPadStart(String(this.day), 2, `0`);
    }
    /**
     * @deprecated use {@link getFormattedDay} instead
     * Formatted whole date
     */
    get formattedDay() {
        return `${this.formattedDayPart}.${this.formattedMonth}`;
    }
    get isWeekend() {
        const dayOfWeek = this.dayOfWeek(false);
        return dayOfWeek === 6 /* PrizmDayOfWeek.Saturday */ || dayOfWeek === 0 /* PrizmDayOfWeek.Sunday */;
    }
    /**
     * Returns day of week
     *
     * @param startFromMonday whether week starts from Monday and not from Sunday
     * @return day of week (from 0 to 6)
     */
    dayOfWeek(startFromMonday = true) {
        const dayOfWeek = startFromMonday
            ? this.toLocalNativeDate().getDay() - 1
            : this.toLocalNativeDate().getDay();
        return dayOfWeek < 0 ? 6 : dayOfWeek;
    }
    /**
     * Passed date is after current
     */
    dayBefore(another) {
        return this.monthBefore(another) || (this.monthSame(another) && this.day < another.day);
    }
    /**
     * Passed date is after or equals to current
     */
    daySameOrBefore(another) {
        return this.monthBefore(another) || (this.monthSame(another) && this.day <= another.day);
    }
    /**
     * Passed date is the same as current
     */
    daySame(another) {
        return this.monthSame(another) && this.day === another.day;
    }
    /**
     * Passed date is either before or the same as current
     */
    daySameOrAfter(another) {
        return this.monthAfter(another) || (this.monthSame(another) && this.day >= another.day);
    }
    /**
     * Passed date is before current
     */
    dayAfter(another) {
        return this.monthAfter(another) || (this.monthSame(another) && this.day > another.day);
    }
    /**
     * Clamping date between two limits
     *
     * @param min
     * @param max
     * @return clamped date
     */
    dayLimit(min, max) {
        if (min !== null && this.dayBefore(min)) {
            return min;
        }
        if (max !== null && this.dayAfter(max)) {
            return max;
        }
        return this;
    }
    // TODO: 2.0 Consider removing `backwards` option
    /**
     * Immutably alters current day by passed offset
     *
     * If resulting month has more days than original one, date is rounded to the maximum day
     * in the resulting month. Offset of days will be calculated based on the resulted year and month
     * to not interfere with parent classes methods
     *
     * @param offset
     * @param backwards shift date backwards
     * @return new date object as a result of offsetting current
     */
    append({ year = 0, month = 0, day = 0 }, backwards = false) {
        if (backwards) {
            year *= -1;
            month *= -1;
            day *= -1;
        }
        const totalMonths = (this.year + year) * PRIZM_MONTHS_IN_YEAR + this.month + month;
        let years = Math.floor(totalMonths / PRIZM_MONTHS_IN_YEAR);
        let months = totalMonths % PRIZM_MONTHS_IN_YEAR;
        let days = Math.min(this.day, PrizmMonth.getMonthDaysCount(months, PrizmYear.isLeapYear(years))) + day;
        while (days > PrizmMonth.getMonthDaysCount(months, PrizmYear.isLeapYear(years))) {
            days -= PrizmMonth.getMonthDaysCount(months, PrizmYear.isLeapYear(years));
            if (months === 11 /* PrizmMonthNumber.December */) {
                years++;
                months = 0 /* PrizmMonthNumber.January */;
            }
            else {
                months++;
            }
        }
        while (days < PRIZM_MIN_DAY) {
            if (months === 0 /* PrizmMonthNumber.January */) {
                years--;
                months = 11 /* PrizmMonthNumber.December */;
            }
            else {
                months--;
            }
            days += PrizmMonth.getMonthDaysCount(months, PrizmYear.isLeapYear(years));
        }
        return new PrizmDay(years, months, days);
    }
    /**
     * Returns formatted whole date
     */
    getFormattedDay(dateFormat, separator) {
        prizmAssert.assert(separator.length === 1, `Separator should consist of only 1 symbol`);
        const dd = this.formattedDayPart;
        const mm = this.formattedMonthPart;
        const yyyy = this.formattedYear;
        switch (dateFormat) {
            case `YMD`:
                return `${yyyy}${separator}${mm}${separator}${dd}`;
            case `MDY`:
                return `${mm}${separator}${dd}${separator}${yyyy}`;
            case `DMY`:
            default:
                return `${dd}${separator}${mm}${separator}${yyyy}`;
        }
    }
    toString(dateFormat = `DMY`, separator = `.`) {
        return this.getFormattedDay(dateFormat, separator);
    }
    toJSON() {
        return `${super.toJSON()}-${this.formattedDayPart}`;
    }
    /**
     * Returns native {@link Date} based on local time zone
     */
    toLocalNativeDate() {
        return new Date(this.year, this.month, this.day);
    }
    /**
     * Returns native {@link Date} based on UTC
     */
    toUtcNativeDate() {
        return new Date(Date.UTC(this.year, this.month, this.day));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jb21wb25lbnRzL3NyYy9saWIvQGNvcmUvZGF0ZS10aW1lL2RheS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUNsRixPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUN0RixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQztBQUdwRixPQUFPLEVBQUUsWUFBWSxFQUFFLHlCQUF5QixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFHMUUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLGFBQWEsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN0RixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ3JDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDbkMsT0FBTyxFQUFFLFdBQVcsRUFBRSxhQUFhLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU1RCw2QkFBNkI7QUFDN0I7O0dBRUc7QUFDSCxNQUFNLE9BQU8sUUFBUyxTQUFRLFVBQVU7SUFDdEMsWUFBWSxJQUFZLEVBQUUsS0FBYSxFQUFXLEdBQVc7UUFDM0QsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUQ2QixRQUFHLEdBQUgsR0FBRyxDQUFRO1FBRTNELFdBQVcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxFQUFFO1lBQ3hELElBQUk7WUFDSixLQUFLO1lBQ0wsR0FBRztTQUNKLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU0s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LEdBQUcsRUFBRSxHQUFHLFNBQVMsR0FBRyxFQUFFLEdBQUcsU0FBUyxHQUFHLElBQUksRUFBRSxDQUFDO1lBQ3JELEtBQUssS0FBSyxDQUFDO1lBQ1g7Z0JBQ0UsT0FBTyxHQUFHLEVBQUUsR0FBRyxTQUFTLEdBQUcsRUFBRSxHQUFHLFNBQVMsR0FBRyxJQUFJLEVBQUUsQ0FBQztTQUN0RDtJQUNILENBQUM7SUFFZSxRQUFRLENBQUMsYUFBNEIsS0FBSyxFQUFFLFNBQVMsR0FBRyxHQUFHO1FBQ3pFLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVlLE1BQU07UUFDcEIsT0FBTyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7O09BRUc7SUFDYSxpQkFBaUI7UUFDL0IsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7T0FFRztJQUNhLGVBQWU7UUFDN0IsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM3RCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcml6bUludmFsaWREYXlFeGNlcHRpb24gfSBmcm9tICcuLi8uLi9leGNlcHRpb25zL2ludmFsaWQtZGF5LmV4Y2VwdGlvbic7XG5pbXBvcnQgeyBQcml6bUludmFsaWRNb250aEV4Y2VwdGlvbiB9IGZyb20gJy4uLy4uL2V4Y2VwdGlvbnMvaW52YWxpZC1tb250aC5leGNlcHRpb24nO1xuaW1wb3J0IHsgUHJpem1JbnZhbGlkWWVhckV4Y2VwdGlvbiB9IGZyb20gJy4uLy4uL2V4Y2VwdGlvbnMvaW52YWxpZC15ZWFyLmV4Y2VwdGlvbic7XG5pbXBvcnQgeyBQcml6bURhdGVNb2RlIH0gZnJvbSAnLi4vLi4vdHlwZXMvZGF0ZS1tb2RlJztcbmltcG9ydCB7IFByaXptRGF5TGlrZSB9IGZyb20gJy4uLy4uL3R5cGVzL2RheS1saWtlJztcbmltcG9ydCB7IHByaXptSW5SYW5nZSwgcHJpem1Ob3JtYWxpemVUb0ludE51bWJlciB9IGZyb20gJy4uLy4uL3V0aWwvbWF0aCc7XG5pbXBvcnQgeyBQcml6bURheU9mV2VlayB9IGZyb20gJy4uL2VudW1zL2RheS1vZi13ZWVrJztcbmltcG9ydCB7IFByaXptTW9udGhOdW1iZXIgfSBmcm9tICcuLi9lbnVtcy9tb250aC1udW1iZXInO1xuaW1wb3J0IHsgUFJJWk1fREFURV9GSUxMRVJfTEVOR1RIIH0gZnJvbSAnLi9kYXRlLWZpbGxlcnMnO1xuaW1wb3J0IHsgUFJJWk1fREFZU19JTl9XRUVLLCBQUklaTV9NSU5fREFZLCBQUklaTV9NT05USFNfSU5fWUVBUiB9IGZyb20gJy4vZGF0ZS10aW1lJztcbmltcG9ydCB7IFByaXptTW9udGggfSBmcm9tICcuL21vbnRoJztcbmltcG9ydCB7IFByaXptWWVhciB9IGZyb20gJy4veWVhcic7XG5pbXBvcnQgeyBwcml6bUFzc2VydCwgcHJpem1QYWRTdGFydCB9IGZyb20gJ0Bwcml6bS11aS9jb3JlJztcblxuLy8gVE9ETzogTG9jYWxpemVkIGZvcm1hdHRpbmdcbi8qKlxuICogSW1tdXRhYmxlIGRhdGUgb2JqZWN0LCBjb25zaXN0aW5nIG9mIGRheSwgbW9udGggYW5kIHllYXJcbiAqL1xuZXhwb3J0IGNsYXNzIFByaXptRGF5IGV4dGVuZHMgUHJpem1Nb250aCB7XG4gIGNvbnN0cnVjdG9yKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgcmVhZG9ubHkgZGF5OiBudW1iZXIpIHtcbiAgICBzdXBlcih5ZWFyLCBtb250aCk7XG4gICAgcHJpem1Bc3NlcnQuYXNzZXJ0KFByaXptRGF5LmlzVmFsaWREYXkoeWVhciwgbW9udGgsIGRheSksIHtcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHtAbGluayBQcml6bURheX0gZnJvbSBuYXRpdmUge0BsaW5rIERhdGV9IGJhc2VkIG9uIGxvY2FsIHRpbWUgem9uZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tTG9jYWxOYXRpdmVEYXRlKGRhdGU6IERhdGUpOiBQcml6bURheSB7XG4gICAgcmV0dXJuIG5ldyBQcml6bURheShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMge0BsaW5rIFByaXptRGF5fSBmcm9tIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gdXNpbmcgVVRDXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21VdGNOYXRpdmVEYXRlKGRhdGU6IERhdGUpOiBQcml6bURheSB7XG4gICAgcmV0dXJuIG5ldyBQcml6bURheShkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHZhbGlkaXR5IG9mIHllYXIsIG1vbnRoIGFuZCBkYXlcbiAgICpcbiAgICogQHBhcmFtIHllYXJcbiAgICogQHBhcmFtIG1vbnRoXG4gICAqIEBwYXJhbSBkYXlcbiAgICogQHJldHVybiBib29sZWFuIHZhbGlkaXR5XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGlzVmFsaWREYXkoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICBQcml6bU1vbnRoLmlzVmFsaWRNb250aCh5ZWFyLCBtb250aCkgJiZcbiAgICAgIE51bWJlci5pc0ludGVnZXIoZGF5KSAmJlxuICAgICAgcHJpem1JblJhbmdlKGRheSwgUFJJWk1fTUlOX0RBWSwgUHJpem1Nb250aC5nZXRNb250aERheXNDb3VudChtb250aCwgUHJpem1ZZWFyLmlzTGVhcFllYXIoeWVhcikpICsgMSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERPTlQgVVNFIElUICh3aWxsIGJlIGRlbGV0ZWQgc29vbilcbiAgICpcbiAgICogQ2FsY3VsYXRlZCBkYXkgb24gYSBjYWxlbmRhciBncmlkXG4gICAqXG4gICAqIEBwYXJhbSBtb250aFxuICAgKiBAcGFyYW0gcm93IHJvdyBpbiBhIGNhbGVuZGFyXG4gICAqIEBwYXJhbSBjb2wgY29sdW1uIGluIGEgY2FsZW5kYXJcbiAgICogQHJldHVybiByZXN1bHRpbmcgZGF5IG9uIHRoZXNlIGNvb3JkaW5hdGVzIChjb3VsZCBleGNlZWQgcGFzc2VkIG1vbnRoKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXREYXlGcm9tTW9udGhSb3dDb2wobW9udGg6IFByaXptTW9udGgsIHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcik6IFByaXptRGF5IHtcbiAgICBwcml6bUFzc2VydC5hc3NlcnQoTnVtYmVyLmlzSW50ZWdlcihyb3cpKTtcbiAgICBwcml6bUFzc2VydC5hc3NlcnQocHJpem1JblJhbmdlKHJvdywgMCwgNikpO1xuICAgIHByaXptQXNzZXJ0LmFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKGNvbCkpO1xuICAgIHByaXptQXNzZXJ0LmFzc2VydChwcml6bUluUmFuZ2UoY29sLCAwLCBQUklaTV9EQVlTX0lOX1dFRUspKTtcblxuICAgIGxldCBkYXkgPSByb3cgKiBQUklaTV9EQVlTX0lOX1dFRUsgKyBjb2wgLSBtb250aC5tb250aFN0YXJ0RGF5c09mZnNldCArIDE7XG5cbiAgICBpZiAoZGF5ID4gbW9udGguZGF5c0NvdW50KSB7XG4gICAgICBkYXkgPSBkYXkgLSBtb250aC5kYXlzQ291bnQ7XG4gICAgICBtb250aCA9IG1vbnRoLmFwcGVuZCh7IG1vbnRoOiAxIH0pO1xuICAgIH1cblxuICAgIGlmIChkYXkgPD0gMCkge1xuICAgICAgbW9udGggPSBtb250aC5hcHBlbmQoeyBtb250aDogLTEgfSk7XG4gICAgICBkYXkgPSBtb250aC5kYXlzQ291bnQgKyBkYXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcml6bURheShtb250aC55ZWFyLCBtb250aC5tb250aCwgZGF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IGRheSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgb3ZlcnJpZGUgY3VycmVudExvY2FsKCk6IFByaXptRGF5IHtcbiAgICBjb25zdCBuYXRpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCB5ZWFyID0gbmF0aXZlRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIGNvbnN0IG1vbnRoID0gbmF0aXZlRGF0ZS5nZXRNb250aCgpO1xuICAgIGNvbnN0IGRheSA9IG5hdGl2ZURhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgcmV0dXJuIG5ldyBQcml6bURheSh5ZWFyLCBtb250aCwgZGF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgZGF5IGJhc2VkIG9uIFVUQ1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBvdmVycmlkZSBjdXJyZW50VXRjKCk6IFByaXptRGF5IHtcbiAgICBjb25zdCBuYXRpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCB5ZWFyID0gbmF0aXZlRGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgIGNvbnN0IG1vbnRoID0gbmF0aXZlRGF0ZS5nZXRVVENNb250aCgpO1xuICAgIGNvbnN0IGRheSA9IG5hdGl2ZURhdGUuZ2V0VVRDRGF0ZSgpO1xuXG4gICAgcmV0dXJuIG5ldyBQcml6bURheSh5ZWFyLCBtb250aCwgZGF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHtAbGluayBQcml6bURheX0gbm9ybWFsaXppbmcgeWVhciwgbW9udGggYW5kIGRheS4ge0BsaW5rIE5hTn0gaXMgdHVybmVkIGludG8gbWluaW1hbCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHllYXIgYW55IHllYXIgdmFsdWUsIGluY2x1ZGluZyBpbnZhbGlkXG4gICAqIEBwYXJhbSBtb250aCBhbnkgbW9udGggdmFsdWUsIGluY2x1ZGluZyBpbnZhbGlkIChtb250aHMgc3RhcnQgd2l0aCAwKVxuICAgKiBAcGFyYW0gZGF5IGFueSBkYXkgdmFsdWUsIGluY2x1ZGluZyBpbnZhbGlkXG4gICAqIEByZXR1cm4gbm9ybWFsaXplZCBkYXRlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG5vcm1hbGl6ZU9mKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIpOiBQcml6bURheSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFllYXIgPSBQcml6bVllYXIubm9ybWFsaXplWWVhclBhcnQoeWVhcik7XG4gICAgY29uc3Qgbm9ybWFsaXplZE1vbnRoID0gUHJpem1Nb250aC5ub3JtYWxpemVNb250aFBhcnQobW9udGgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWREYXkgPSBQcml6bURheS5ub3JtYWxpemVEYXlQYXJ0KGRheSwgbm9ybWFsaXplZE1vbnRoLCBub3JtYWxpemVkWWVhcik7XG5cbiAgICByZXR1cm4gbmV3IFByaXptRGF5KG5vcm1hbGl6ZWRZZWFyLCBub3JtYWxpemVkTW9udGgsIG5vcm1hbGl6ZWREYXkpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBvdmVycmlkZSBsZW5ndGhCZXR3ZWVuKGZyb206IFByaXptRGF5LCB0bzogUHJpem1EYXkpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKFxuICAgICAgKHRvLnRvTG9jYWxOYXRpdmVEYXRlKCkuZ2V0VGltZSgpIC0gZnJvbS50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNClcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBwYXJzZVJhd0RhdGVTdHJpbmcoXG4gICAgZGF0ZTogc3RyaW5nLFxuICAgIGRhdGVNb2RlOiBQcml6bURhdGVNb2RlID0gYERNWWBcbiAgKTogeyBkYXk6IG51bWJlcjsgbW9udGg6IG51bWJlcjsgeWVhcjogbnVtYmVyIH0ge1xuICAgIHByaXptQXNzZXJ0LmFzc2VydChcbiAgICAgIGRhdGUubGVuZ3RoID09PSBQUklaTV9EQVRFX0ZJTExFUl9MRU5HVEgsXG4gICAgICBgW3BhcnNlUmF3RGF0ZVN0cmluZ106IHdyb25nIGRhdGUgc3RyaW5nIGxlbmd0aGBcbiAgICApO1xuXG4gICAgc3dpdGNoIChkYXRlTW9kZSkge1xuICAgICAgY2FzZSBgWU1EYDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXk6IHBhcnNlSW50KGRhdGUuc2xpY2UoOCwgMTApLCAxMCksXG4gICAgICAgICAgbW9udGg6IHBhcnNlSW50KGRhdGUuc2xpY2UoNSwgNyksIDEwKSAtIDEsXG4gICAgICAgICAgeWVhcjogcGFyc2VJbnQoZGF0ZS5zbGljZSgwLCA0KSwgMTApLFxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGBNRFlgOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRheTogcGFyc2VJbnQoZGF0ZS5zbGljZSgzLCA1KSwgMTApLFxuICAgICAgICAgIG1vbnRoOiBwYXJzZUludChkYXRlLnNsaWNlKDAsIDIpLCAxMCkgLSAxLFxuICAgICAgICAgIHllYXI6IHBhcnNlSW50KGRhdGUuc2xpY2UoNiwgMTApLCAxMCksXG4gICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlIGBETVlgOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRheTogcGFyc2VJbnQoZGF0ZS5zbGljZSgwLCAyKSwgMTApLFxuICAgICAgICAgIG1vbnRoOiBwYXJzZUludChkYXRlLnNsaWNlKDMsIDUpLCAxMCkgLSAxLFxuICAgICAgICAgIHllYXI6IHBhcnNlSW50KGRhdGUuc2xpY2UoNiwgMTApLCAxMCksXG4gICAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTW92ZSBtb250aCBhbmQgeWVhciByZWxhdGVkIGNvZGUgY29ycmVzcG9uZGluZyBjbGFzc2VzXG4gIC8qKlxuICAgKiBQYXJzaW5nIGEgc3RyaW5nIHdpdGggZGF0ZSB3aXRoIG5vcm1hbGl6YXRpb25cbiAgICpcbiAgICogQHBhcmFtIHJhd0RhdGUgZGF0ZSBzdHJpbmdcbiAgICogQHBhcmFtIGRhdGVNb2RlIGRhdGUgZm9ybWF0IG9mIHRoZSBkYXRlIHN0cmluZyAoRE1ZIHwgTURZIHwgWU1EKVxuICAgKiBAcmV0dXJuIG5vcm1hbGl6ZWQgZGF0ZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBub3JtYWxpemVQYXJzZShyYXdEYXRlOiBzdHJpbmcsIGRhdGVNb2RlOiBQcml6bURhdGVNb2RlID0gYERNWWApOiBQcml6bURheSB7XG4gICAgY29uc3QgeyBkYXksIG1vbnRoLCB5ZWFyIH0gPSB0aGlzLnBhcnNlUmF3RGF0ZVN0cmluZyhyYXdEYXRlLCBkYXRlTW9kZSk7XG5cbiAgICByZXR1cm4gUHJpem1EYXkubm9ybWFsaXplT2YoeWVhciwgbW9udGgsIGRheSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2luZyBhIGRhdGUgc3RyaW5naWZpZWQgaW4gYSB0b0pTT04gZm9ybWF0XG4gICAqIEBwYXJhbSB5ZWFyTW9udGhEYXlTdHJpbmcgZGF0ZSBzdHJpbmcgaW4gZm9ybWF0IG9mIFlZWVktTU0tRERcbiAgICogQHJldHVybiBkYXRlXG4gICAqIEB0aHJvd3MgZXhjZXB0aW9ucyBpZiBhbnkgcGFydCBvZiB0aGUgZGF0ZSBpcyBpbnZhbGlkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGpzb25QYXJzZSh5ZWFyTW9udGhEYXlTdHJpbmc6IHN0cmluZyk6IFByaXptRGF5IHtcbiAgICBjb25zdCB7IGRheSwgbW9udGgsIHllYXIgfSA9IHRoaXMucGFyc2VSYXdEYXRlU3RyaW5nKHllYXJNb250aERheVN0cmluZywgYFlNRGApO1xuXG4gICAgaWYgKCFQcml6bVllYXIuaXNWYWxpZFllYXIoeWVhcikpIHtcbiAgICAgIHRocm93IG5ldyBQcml6bUludmFsaWRZZWFyRXhjZXB0aW9uKHllYXIpO1xuICAgIH1cblxuICAgIGlmICghUHJpem1Nb250aC5pc1ZhbGlkTW9udGgoeWVhciwgbW9udGgpKSB7XG4gICAgICB0aHJvdyBuZXcgUHJpem1JbnZhbGlkTW9udGhFeGNlcHRpb24obW9udGgpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKGRheSkgfHxcbiAgICAgICFwcml6bUluUmFuZ2UoZGF5LCBQUklaTV9NSU5fREFZLCBQcml6bU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRoLCBQcml6bVllYXIuaXNMZWFwWWVhcih5ZWFyKSkgKyAxKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFByaXptSW52YWxpZERheUV4Y2VwdGlvbihkYXkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJpem1EYXkoeWVhciwgbW9udGgsIGRheSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhdGljIG5vcm1hbGl6ZURheVBhcnQoZGF5OiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIHllYXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgcHJpem1Bc3NlcnQuYXNzZXJ0KFByaXptTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSk7XG5cbiAgICBjb25zdCBtb250aERheXNDb3VudCA9IFByaXptTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGgsIFByaXptWWVhci5pc0xlYXBZZWFyKHllYXIpKTtcblxuICAgIHJldHVybiBwcml6bU5vcm1hbGl6ZVRvSW50TnVtYmVyKGRheSwgMSwgbW9udGhEYXlzQ291bnQpO1xuICB9XG5cbiAgZ2V0IGZvcm1hdHRlZERheVBhcnQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcHJpem1QYWRTdGFydChTdHJpbmcodGhpcy5kYXkpLCAyLCBgMGApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgZ2V0Rm9ybWF0dGVkRGF5fSBpbnN0ZWFkXG4gICAqIEZvcm1hdHRlZCB3aG9sZSBkYXRlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGZvcm1hdHRlZERheSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmZvcm1hdHRlZERheVBhcnR9LiR7dGhpcy5mb3JtYXR0ZWRNb250aH1gO1xuICB9XG5cbiAgcHVibGljIGdldCBpc1dlZWtlbmQoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZGF5T2ZXZWVrID0gdGhpcy5kYXlPZldlZWsoZmFsc2UpO1xuXG4gICAgcmV0dXJuIGRheU9mV2VlayA9PT0gUHJpem1EYXlPZldlZWsuU2F0dXJkYXkgfHwgZGF5T2ZXZWVrID09PSBQcml6bURheU9mV2Vlay5TdW5kYXk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBkYXkgb2Ygd2Vla1xuICAgKlxuICAgKiBAcGFyYW0gc3RhcnRGcm9tTW9uZGF5IHdoZXRoZXIgd2VlayBzdGFydHMgZnJvbSBNb25kYXkgYW5kIG5vdCBmcm9tIFN1bmRheVxuICAgKiBAcmV0dXJuIGRheSBvZiB3ZWVrIChmcm9tIDAgdG8gNilcbiAgICovXG4gIHB1YmxpYyBkYXlPZldlZWsoc3RhcnRGcm9tTW9uZGF5ID0gdHJ1ZSk6IG51bWJlciB7XG4gICAgY29uc3QgZGF5T2ZXZWVrID0gc3RhcnRGcm9tTW9uZGF5XG4gICAgICA/IHRoaXMudG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXREYXkoKSAtIDFcbiAgICAgIDogdGhpcy50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldERheSgpO1xuXG4gICAgcmV0dXJuIGRheU9mV2VlayA8IDAgPyA2IDogZGF5T2ZXZWVrO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhc3NlZCBkYXRlIGlzIGFmdGVyIGN1cnJlbnRcbiAgICovXG4gIHB1YmxpYyBkYXlCZWZvcmUoYW5vdGhlcjogUHJpem1EYXkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5tb250aEJlZm9yZShhbm90aGVyKSB8fCAodGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPCBhbm90aGVyLmRheSk7XG4gIH1cblxuICAvKipcbiAgICogUGFzc2VkIGRhdGUgaXMgYWZ0ZXIgb3IgZXF1YWxzIHRvIGN1cnJlbnRcbiAgICovXG4gIHB1YmxpYyBkYXlTYW1lT3JCZWZvcmUoYW5vdGhlcjogUHJpem1EYXkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5tb250aEJlZm9yZShhbm90aGVyKSB8fCAodGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPD0gYW5vdGhlci5kYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhc3NlZCBkYXRlIGlzIHRoZSBzYW1lIGFzIGN1cnJlbnRcbiAgICovXG4gIHB1YmxpYyBkYXlTYW1lKGFub3RoZXI6IFByaXptRGF5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5ID09PSBhbm90aGVyLmRheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXNzZWQgZGF0ZSBpcyBlaXRoZXIgYmVmb3JlIG9yIHRoZSBzYW1lIGFzIGN1cnJlbnRcbiAgICovXG4gIHB1YmxpYyBkYXlTYW1lT3JBZnRlcihhbm90aGVyOiBQcml6bURheSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm1vbnRoQWZ0ZXIoYW5vdGhlcikgfHwgKHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5ID49IGFub3RoZXIuZGF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXNzZWQgZGF0ZSBpcyBiZWZvcmUgY3VycmVudFxuICAgKi9cbiAgcHVibGljIGRheUFmdGVyKGFub3RoZXI6IFByaXptRGF5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubW9udGhBZnRlcihhbm90aGVyKSB8fCAodGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPiBhbm90aGVyLmRheSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xhbXBpbmcgZGF0ZSBiZXR3ZWVuIHR3byBsaW1pdHNcbiAgICpcbiAgICogQHBhcmFtIG1pblxuICAgKiBAcGFyYW0gbWF4XG4gICAqIEByZXR1cm4gY2xhbXBlZCBkYXRlXG4gICAqL1xuICBwdWJsaWMgZGF5TGltaXQobWluOiBQcml6bURheSB8IG51bGwsIG1heDogUHJpem1EYXkgfCBudWxsKTogUHJpem1EYXkge1xuICAgIGlmIChtaW4gIT09IG51bGwgJiYgdGhpcy5kYXlCZWZvcmUobWluKSkge1xuICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG5cbiAgICBpZiAobWF4ICE9PSBudWxsICYmIHRoaXMuZGF5QWZ0ZXIobWF4KSkge1xuICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFRPRE86IDIuMCBDb25zaWRlciByZW1vdmluZyBgYmFja3dhcmRzYCBvcHRpb25cbiAgLyoqXG4gICAqIEltbXV0YWJseSBhbHRlcnMgY3VycmVudCBkYXkgYnkgcGFzc2VkIG9mZnNldFxuICAgKlxuICAgKiBJZiByZXN1bHRpbmcgbW9udGggaGFzIG1vcmUgZGF5cyB0aGFuIG9yaWdpbmFsIG9uZSwgZGF0ZSBpcyByb3VuZGVkIHRvIHRoZSBtYXhpbXVtIGRheVxuICAgKiBpbiB0aGUgcmVzdWx0aW5nIG1vbnRoLiBPZmZzZXQgb2YgZGF5cyB3aWxsIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIHJlc3VsdGVkIHllYXIgYW5kIG1vbnRoXG4gICAqIHRvIG5vdCBpbnRlcmZlcmUgd2l0aCBwYXJlbnQgY2xhc3NlcyBtZXRob2RzXG4gICAqXG4gICAqIEBwYXJhbSBvZmZzZXRcbiAgICogQHBhcmFtIGJhY2t3YXJkcyBzaGlmdCBkYXRlIGJhY2t3YXJkc1xuICAgKiBAcmV0dXJuIG5ldyBkYXRlIG9iamVjdCBhcyBhIHJlc3VsdCBvZiBvZmZzZXR0aW5nIGN1cnJlbnRcbiAgICovXG4gIHB1YmxpYyBvdmVycmlkZSBhcHBlbmQoeyB5ZWFyID0gMCwgbW9udGggPSAwLCBkYXkgPSAwIH06IFByaXptRGF5TGlrZSwgYmFja3dhcmRzID0gZmFsc2UpOiBQcml6bURheSB7XG4gICAgaWYgKGJhY2t3YXJkcykge1xuICAgICAgeWVhciAqPSAtMTtcbiAgICAgIG1vbnRoICo9IC0xO1xuICAgICAgZGF5ICo9IC0xO1xuICAgIH1cblxuICAgIGNvbnN0IHRvdGFsTW9udGhzID0gKHRoaXMueWVhciArIHllYXIpICogUFJJWk1fTU9OVEhTX0lOX1lFQVIgKyB0aGlzLm1vbnRoICsgbW9udGg7XG4gICAgbGV0IHllYXJzID0gTWF0aC5mbG9vcih0b3RhbE1vbnRocyAvIFBSSVpNX01PTlRIU19JTl9ZRUFSKTtcbiAgICBsZXQgbW9udGhzID0gdG90YWxNb250aHMgJSBQUklaTV9NT05USFNfSU5fWUVBUjtcblxuICAgIGxldCBkYXlzID0gTWF0aC5taW4odGhpcy5kYXksIFByaXptTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBQcml6bVllYXIuaXNMZWFwWWVhcih5ZWFycykpKSArIGRheTtcblxuICAgIHdoaWxlIChkYXlzID4gUHJpem1Nb250aC5nZXRNb250aERheXNDb3VudChtb250aHMsIFByaXptWWVhci5pc0xlYXBZZWFyKHllYXJzKSkpIHtcbiAgICAgIGRheXMgLT0gUHJpem1Nb250aC5nZXRNb250aERheXNDb3VudChtb250aHMsIFByaXptWWVhci5pc0xlYXBZZWFyKHllYXJzKSk7XG5cbiAgICAgIGlmIChtb250aHMgPT09IFByaXptTW9udGhOdW1iZXIuRGVjZW1iZXIpIHtcbiAgICAgICAgeWVhcnMrKztcbiAgICAgICAgbW9udGhzID0gUHJpem1Nb250aE51bWJlci5KYW51YXJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9udGhzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGRheXMgPCBQUklaTV9NSU5fREFZKSB7XG4gICAgICBpZiAobW9udGhzID09PSBQcml6bU1vbnRoTnVtYmVyLkphbnVhcnkpIHtcbiAgICAgICAgeWVhcnMtLTtcbiAgICAgICAgbW9udGhzID0gUHJpem1Nb250aE51bWJlci5EZWNlbWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vbnRocy0tO1xuICAgICAgfVxuXG4gICAgICBkYXlzICs9IFByaXptTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBQcml6bVllYXIuaXNMZWFwWWVhcih5ZWFycykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJpem1EYXkoeWVhcnMsIG1vbnRocywgZGF5cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmb3JtYXR0ZWQgd2hvbGUgZGF0ZVxuICAgKi9cbiAgcHVibGljIGdldEZvcm1hdHRlZERheShkYXRlRm9ybWF0OiBQcml6bURhdGVNb2RlLCBzZXBhcmF0b3I6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcHJpem1Bc3NlcnQuYXNzZXJ0KHNlcGFyYXRvci5sZW5ndGggPT09IDEsIGBTZXBhcmF0b3Igc2hvdWxkIGNvbnNpc3Qgb2Ygb25seSAxIHN5bWJvbGApO1xuXG4gICAgY29uc3QgZGQgPSB0aGlzLmZvcm1hdHRlZERheVBhcnQ7XG4gICAgY29uc3QgbW0gPSB0aGlzLmZvcm1hdHRlZE1vbnRoUGFydDtcbiAgICBjb25zdCB5eXl5ID0gdGhpcy5mb3JtYXR0ZWRZZWFyO1xuXG4gICAgc3dpdGNoIChkYXRlRm9ybWF0KSB7XG4gICAgICBjYXNlIGBZTURgOlxuICAgICAgICByZXR1cm4gYCR7eXl5eX0ke3NlcGFyYXRvcn0ke21tfSR7c2VwYXJhdG9yfSR7ZGR9YDtcbiAgICAgIGNhc2UgYE1EWWA6XG4gICAgICAgIHJldHVybiBgJHttbX0ke3NlcGFyYXRvcn0ke2RkfSR7c2VwYXJhdG9yfSR7eXl5eX1gO1xuICAgICAgY2FzZSBgRE1ZYDpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgJHtkZH0ke3NlcGFyYXRvcn0ke21tfSR7c2VwYXJhdG9yfSR7eXl5eX1gO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBvdmVycmlkZSB0b1N0cmluZyhkYXRlRm9ybWF0OiBQcml6bURhdGVNb2RlID0gYERNWWAsIHNlcGFyYXRvciA9IGAuYCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Rm9ybWF0dGVkRGF5KGRhdGVGb3JtYXQsIHNlcGFyYXRvcik7XG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUgdG9KU09OKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3N1cGVyLnRvSlNPTigpfS0ke3RoaXMuZm9ybWF0dGVkRGF5UGFydH1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICovXG4gIHB1YmxpYyBvdmVycmlkZSB0b0xvY2FsTmF0aXZlRGF0ZSgpOiBEYXRlIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBuYXRpdmUge0BsaW5rIERhdGV9IGJhc2VkIG9uIFVUQ1xuICAgKi9cbiAgcHVibGljIG92ZXJyaWRlIHRvVXRjTmF0aXZlRGF0ZSgpOiBEYXRlIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEModGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSkpO1xuICB9XG59XG4iXX0=