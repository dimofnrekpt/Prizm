// TODO: 2.0 Remove export in ivy compilation
import { PRIZM_DAYS_IN_WEEK } from '../../@core/date-time/date-time';
import { PrizmDay } from '../../@core/date-time/day';
import { prizmInRange } from '../../util/math/in-range';
import { prizmAssert } from '@prizm-ui/core';
/**
 * Computes day of week offset of the beginning of the month
 */
export const getMonthStartDaysOffset = (month, firstDayOfWeek) => {
    const startMonthOffsetFromSunday = new Date(month.year, month.month, 1).getDay();
    return startMonthOffsetFromSunday >= firstDayOfWeek
        ? startMonthOffsetFromSunday - firstDayOfWeek
        : PRIZM_DAYS_IN_WEEK - (firstDayOfWeek - startMonthOffsetFromSunday);
};
/*
TODO: 2.0 delete:
 * PrizmDay.getDayFromMonthRowCol
 * PrizmMonth.monthStartDaysOffset
 * PrizmMonth.weeksRowsCount
 * PrizmYear.yearStartDaysOffset
 * PrizmYear.getYearStartDaysOffset
 */
/**
 * Calculated day on a calendar grid
 * @return resulting day on these coordinates (could exceed passed month)
 */
export const getDayFromMonthRowCol = ({ month, rowIndex, colIndex, firstDayOfWeek, }) => {
    prizmAssert.assert(Number.isInteger(rowIndex));
    prizmAssert.assert(prizmInRange(rowIndex, 0, 6));
    prizmAssert.assert(Number.isInteger(colIndex));
    prizmAssert.assert(prizmInRange(colIndex, 0, PRIZM_DAYS_IN_WEEK));
    let day = rowIndex * PRIZM_DAYS_IN_WEEK + colIndex - getMonthStartDaysOffset(month, firstDayOfWeek) + 1;
    if (day > month.daysCount) {
        day = day - month.daysCount;
        month = month.append({ month: 1 });
    }
    if (day <= 0) {
        month = month.append({ month: -1 });
        day = month.daysCount + day;
    }
    return new PrizmDay(month.year, month.month, day);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL2NvbXBvbmVudHMvc3JjL2xpYi9waXBlcy9jYWxlbmRhci1zaGVldC91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw2Q0FBNkM7QUFFN0MsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDckUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBR3JELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFN0M7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSx1QkFBdUIsR0FBRyxDQUFDLEtBQWlCLEVBQUUsY0FBOEIsRUFBVSxFQUFFO0lBQ25HLE1BQU0sMEJBQTBCLEdBQUcsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBRWpGLE9BQU8sMEJBQTBCLElBQUksY0FBYztRQUNqRCxDQUFDLENBQUMsMEJBQTBCLEdBQUcsY0FBYztRQUM3QyxDQUFDLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxjQUFjLEdBQUcsMEJBQTBCLENBQUMsQ0FBQztBQUN6RSxDQUFDLENBQUM7QUFFRjs7Ozs7OztHQU9HO0FBQ0g7OztHQUdHO0FBQ0gsTUFBTSxDQUFDLE1BQU0scUJBQXFCLEdBQUcsQ0FBQyxFQUNwQyxLQUFLLEVBQ0wsUUFBUSxFQUNSLFFBQVEsRUFDUixjQUFjLEdBZWYsRUFBWSxFQUFFO0lBQ2IsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDL0MsV0FBVyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pELFdBQVcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQy9DLFdBQVcsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO0lBRWxFLElBQUksR0FBRyxHQUFHLFFBQVEsR0FBRyxrQkFBa0IsR0FBRyxRQUFRLEdBQUcsdUJBQXVCLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUV4RyxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsU0FBUyxFQUFFO1FBQ3pCLEdBQUcsR0FBRyxHQUFHLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztRQUM1QixLQUFLLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ3BDO0lBRUQsSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQ1osS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3BDLEdBQUcsR0FBRyxLQUFLLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQztLQUM3QjtJQUVELE9BQU8sSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3BELENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE86IDIuMCBSZW1vdmUgZXhwb3J0IGluIGl2eSBjb21waWxhdGlvblxuXG5pbXBvcnQgeyBQUklaTV9EQVlTX0lOX1dFRUsgfSBmcm9tICcuLi8uLi9AY29yZS9kYXRlLXRpbWUvZGF0ZS10aW1lJztcbmltcG9ydCB7IFByaXptRGF5IH0gZnJvbSAnLi4vLi4vQGNvcmUvZGF0ZS10aW1lL2RheSc7XG5pbXBvcnQgeyBQcml6bU1vbnRoIH0gZnJvbSAnLi4vLi4vQGNvcmUvZGF0ZS10aW1lL21vbnRoJztcbmltcG9ydCB7IFByaXptRGF5T2ZXZWVrIH0gZnJvbSAnLi4vLi4vQGNvcmUvZW51bXMvZGF5LW9mLXdlZWsnO1xuaW1wb3J0IHsgcHJpem1JblJhbmdlIH0gZnJvbSAnLi4vLi4vdXRpbC9tYXRoL2luLXJhbmdlJztcbmltcG9ydCB7IHByaXptQXNzZXJ0IH0gZnJvbSAnQHByaXptLXVpL2NvcmUnO1xuXG4vKipcbiAqIENvbXB1dGVzIGRheSBvZiB3ZWVrIG9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtb250aFxuICovXG5leHBvcnQgY29uc3QgZ2V0TW9udGhTdGFydERheXNPZmZzZXQgPSAobW9udGg6IFByaXptTW9udGgsIGZpcnN0RGF5T2ZXZWVrOiBQcml6bURheU9mV2Vlayk6IG51bWJlciA9PiB7XG4gIGNvbnN0IHN0YXJ0TW9udGhPZmZzZXRGcm9tU3VuZGF5ID0gbmV3IERhdGUobW9udGgueWVhciwgbW9udGgubW9udGgsIDEpLmdldERheSgpO1xuXG4gIHJldHVybiBzdGFydE1vbnRoT2Zmc2V0RnJvbVN1bmRheSA+PSBmaXJzdERheU9mV2Vla1xuICAgID8gc3RhcnRNb250aE9mZnNldEZyb21TdW5kYXkgLSBmaXJzdERheU9mV2Vla1xuICAgIDogUFJJWk1fREFZU19JTl9XRUVLIC0gKGZpcnN0RGF5T2ZXZWVrIC0gc3RhcnRNb250aE9mZnNldEZyb21TdW5kYXkpO1xufTtcblxuLypcblRPRE86IDIuMCBkZWxldGU6XG4gKiBQcml6bURheS5nZXREYXlGcm9tTW9udGhSb3dDb2xcbiAqIFByaXptTW9udGgubW9udGhTdGFydERheXNPZmZzZXRcbiAqIFByaXptTW9udGgud2Vla3NSb3dzQ291bnRcbiAqIFByaXptWWVhci55ZWFyU3RhcnREYXlzT2Zmc2V0XG4gKiBQcml6bVllYXIuZ2V0WWVhclN0YXJ0RGF5c09mZnNldFxuICovXG4vKipcbiAqIENhbGN1bGF0ZWQgZGF5IG9uIGEgY2FsZW5kYXIgZ3JpZFxuICogQHJldHVybiByZXN1bHRpbmcgZGF5IG9uIHRoZXNlIGNvb3JkaW5hdGVzIChjb3VsZCBleGNlZWQgcGFzc2VkIG1vbnRoKVxuICovXG5leHBvcnQgY29uc3QgZ2V0RGF5RnJvbU1vbnRoUm93Q29sID0gKHtcbiAgbW9udGgsXG4gIHJvd0luZGV4LFxuICBjb2xJbmRleCxcbiAgZmlyc3REYXlPZldlZWssXG59OiB7XG4gIG1vbnRoOiBQcml6bU1vbnRoO1xuICAvKipcbiAgICogcm93IGluIGEgY2FsZW5kYXJcbiAgICovXG4gIHJvd0luZGV4OiBudW1iZXI7XG4gIC8qKlxuICAgKiBjb2x1bW4gaW4gYSBjYWxlbmRhclxuICAgKi9cbiAgY29sSW5kZXg6IG51bWJlcjtcbiAgLyoqXG4gICAqIGZpcnN0IGRheSBvZiB0aGUgd2VlayBpbmRleCAoU3VuZGF5IC0gMCwgU2F0dXJkYXkgLSA2KVxuICAgKi9cbiAgZmlyc3REYXlPZldlZWs6IFByaXptRGF5T2ZXZWVrO1xufSk6IFByaXptRGF5ID0+IHtcbiAgcHJpem1Bc3NlcnQuYXNzZXJ0KE51bWJlci5pc0ludGVnZXIocm93SW5kZXgpKTtcbiAgcHJpem1Bc3NlcnQuYXNzZXJ0KHByaXptSW5SYW5nZShyb3dJbmRleCwgMCwgNikpO1xuICBwcml6bUFzc2VydC5hc3NlcnQoTnVtYmVyLmlzSW50ZWdlcihjb2xJbmRleCkpO1xuICBwcml6bUFzc2VydC5hc3NlcnQocHJpem1JblJhbmdlKGNvbEluZGV4LCAwLCBQUklaTV9EQVlTX0lOX1dFRUspKTtcblxuICBsZXQgZGF5ID0gcm93SW5kZXggKiBQUklaTV9EQVlTX0lOX1dFRUsgKyBjb2xJbmRleCAtIGdldE1vbnRoU3RhcnREYXlzT2Zmc2V0KG1vbnRoLCBmaXJzdERheU9mV2VlaykgKyAxO1xuXG4gIGlmIChkYXkgPiBtb250aC5kYXlzQ291bnQpIHtcbiAgICBkYXkgPSBkYXkgLSBtb250aC5kYXlzQ291bnQ7XG4gICAgbW9udGggPSBtb250aC5hcHBlbmQoeyBtb250aDogMSB9KTtcbiAgfVxuXG4gIGlmIChkYXkgPD0gMCkge1xuICAgIG1vbnRoID0gbW9udGguYXBwZW5kKHsgbW9udGg6IC0xIH0pO1xuICAgIGRheSA9IG1vbnRoLmRheXNDb3VudCArIGRheTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJpem1EYXkobW9udGgueWVhciwgbW9udGgubW9udGgsIGRheSk7XG59O1xuIl19