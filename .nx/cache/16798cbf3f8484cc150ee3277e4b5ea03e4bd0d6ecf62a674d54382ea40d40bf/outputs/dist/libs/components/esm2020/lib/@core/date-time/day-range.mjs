import { PRIZM_DATE_FILLER_LENGTH, PRIZM_DATE_RANGE_FILLER_LENGTH } from './date-fillers';
import { PRIZM_RANGE_SEPARATOR_CHAR } from './date-time';
import { PrizmDay } from './day';
import { PrizmMonthRange } from './month-range';
import { prizmAssert } from '@prizm-ui/core';
/**
 * Temporary type guard to satisfy ts-overloading of normalizeParse method
 * @deprecated
 */
export const prizmIsDateMode = (dateMode) => [`DMY`, `YMD`, `MDY`].includes(dateMode);
/**
 * An immutable range of two {@link PrizmDay} objects
 */
export class PrizmDayRange extends PrizmMonthRange {
    constructor(from, to) {
        super(from, to);
        this.from = from;
        this.to = to;
        if (from && to)
            prizmAssert.assert(from.daySameOrBefore(to));
    }
    /**
     * Creates range from two days after sorting them
     *
     * @param day1
     * @param day2
     * @return new range with sorted days
     */
    static sort(day1, day2) {
        return day1.daySameOrBefore(day2) ? new PrizmDayRange(day1, day2) : new PrizmDayRange(day2, day1);
    }
    static fromLocalNativeDate(date1, date2) {
        return new PrizmDayRange(PrizmDay.fromLocalNativeDate(date1), PrizmDay.fromLocalNativeDate(date2));
    }
    /**
     * Parse and correct a day range in string format
     *
     * @param rangeString a string of dates in a format dd.mm.yyyy - dd.mm.yyyy
     * @param dateMode {@link PrizmDateMode}
     * @return normalized day range object
     */
    static normalizeParse(rangeString, dateMode = `DMY`) {
        const dateFormat = prizmIsDateMode(dateMode) ? dateMode : `DMY`;
        const leftDay = PrizmDay.normalizeParse(rangeString.slice(0, PRIZM_DATE_FILLER_LENGTH), dateFormat);
        if (rangeString.length < PRIZM_DATE_RANGE_FILLER_LENGTH) {
            return new PrizmDayRange(leftDay, leftDay);
        }
        return PrizmDayRange.sort(leftDay, PrizmDay.normalizeParse(rangeString.slice(PRIZM_DATE_FILLER_LENGTH + PRIZM_RANGE_SEPARATOR_CHAR.length), dateFormat));
    }
    get isSingleDay() {
        return this.from.daySame(this.to);
    }
    /**
     * Human readable format.
     * @deprecated use {@link getFormattedDayRange} instead
     */
    get formattedDayRange() {
        const from = this.from.getFormattedDay(`DMY`, `.`);
        const to = this.to.getFormattedDay(`DMY`, `.`);
        return `${from}${PRIZM_RANGE_SEPARATOR_CHAR}${to}`;
    }
    isDayInRange(day) {
        return day.daySameOrAfter(this.from) && day.daySameOrBefore(this.to);
    }
    /**
     * Tests ranges for identity
     *
     * @param another second range to test against current
     * @return `true` if days are identical
     */
    daySame(another) {
        return this.from.daySame(another.from) && this.to.daySame(another.to);
    }
    /**
     * Locks range between two days included, or limits from one side if the other is null
     *
     * @param min
     * @param max
     * @return range â€” clamped range
     */
    dayLimit(min, max) {
        return new PrizmDayRange(this.from.dayLimit(min, max), this.to.dayLimit(min, max));
    }
    /**
     * Human readable format.
     */
    getFormattedDayRange(dateFormat, dateSeparator) {
        const from = this.from.getFormattedDay(dateFormat, dateSeparator);
        const to = this.to?.getFormattedDay(dateFormat, dateSeparator) ?? '';
        return `${from}${PRIZM_RANGE_SEPARATOR_CHAR}${to}`;
    }
    toLocalNativeDate() {
        return [this.from?.toLocalNativeDate() ?? null, this.to?.toLocalNativeDate() ?? null];
    }
    toString(dateFormat = `DMY`, dateSeparator = `.`) {
        const from = this.from.getFormattedDay(dateFormat, dateSeparator);
        const to = this.to?.getFormattedDay(dateFormat, dateSeparator) ?? '';
        return `${from}${PRIZM_RANGE_SEPARATOR_CHAR}${to}`;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LXJhbmdlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9jb21wb25lbnRzL3NyYy9saWIvQGNvcmUvZGF0ZS10aW1lL2RheS1yYW5nZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsOEJBQThCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMxRixPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDekQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLE9BQU8sQ0FBQztBQUNqQyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRWhELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU3Qzs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxRQUFnQixFQUE2QixFQUFFLENBQzdFLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7QUFFM0M7O0dBRUc7QUFDSCxNQUFNLE9BQU8sYUFBYyxTQUFRLGVBQWU7SUFDaEQsWUFBOEIsSUFBYyxFQUFvQixFQUFZO1FBQzFFLEtBQUssQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFEWSxTQUFJLEdBQUosSUFBSSxDQUFVO1FBQW9CLE9BQUUsR0FBRixFQUFFLENBQVU7UUFHMUUsSUFBSSxJQUFJLElBQUksRUFBRTtZQUFFLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxNQUFNLENBQVUsSUFBSSxDQUFDLElBQWMsRUFBRSxJQUFjO1FBQ3hELE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFB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UUFFckUsT0FBTyxHQUFHLElBQUksR0FBRywwQkFBMEIsR0FBRyxFQUFFLEVBQUUsQ0FBQztJQUNyRCxDQUFDO0lBRU0saUJBQWlCO1FBQ3RCLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLGlCQUFpQixFQUFFLElBQUksSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxJQUFJLENBQUMsQ0FBQztJQUN4RixDQUFDO0lBRWUsUUFBUSxDQUFDLGFBQTRCLEtBQUssRUFBRSxhQUFhLEdBQUcsR0FBRztRQUM3RSxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDbEUsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxlQUFlLENBQUMsVUFBVSxFQUFFLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUVyRSxPQUFPLEdBQUcsSUFBSSxHQUFHLDBCQUEwQixHQUFHLEVBQUUsRUFBRSxDQUFDO0lBQ3JELENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByaXptRGF0ZU1vZGUgfSBmcm9tICcuLi8uLi90eXBlcy9kYXRlLW1vZGUnO1xuaW1wb3J0IHsgUFJJWk1fREFURV9GSUxMRVJfTEVOR1RILCBQUklaTV9EQVRFX1JBTkdFX0ZJTExFUl9MRU5HVEggfSBmcm9tICcuL2RhdGUtZmlsbGVycyc7XG5pbXBvcnQgeyBQUklaTV9SQU5HRV9TRVBBUkFUT1JfQ0hBUiB9IGZyb20gJy4vZGF0ZS10aW1lJztcbmltcG9ydCB7IFByaXptRGF5IH0gZnJvbSAnLi9kYXknO1xuaW1wb3J0IHsgUHJpem1Nb250aFJhbmdlIH0gZnJvbSAnLi9tb250aC1yYW5nZSc7XG5cbmltcG9ydCB7IHByaXptQXNzZXJ0IH0gZnJvbSAnQHByaXptLXVpL2NvcmUnO1xuXG4vKipcbiAqIFRlbXBvcmFyeSB0eXBlIGd1YXJkIHRvIHNhdGlzZnkgdHMtb3ZlcmxvYWRpbmcgb2Ygbm9ybWFsaXplUGFyc2UgbWV0aG9kXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgY29uc3QgcHJpem1Jc0RhdGVNb2RlID0gKGRhdGVNb2RlOiBzdHJpbmcpOiBkYXRlTW9kZSBpcyBQcml6bURhdGVNb2RlID0+XG4gIFtgRE1ZYCwgYFlNRGAsIGBNRFlgXS5pbmNsdWRlcyhkYXRlTW9kZSk7XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIHJhbmdlIG9mIHR3byB7QGxpbmsgUHJpem1EYXl9IG9iamVjdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFByaXptRGF5UmFuZ2UgZXh0ZW5kcyBQcml6bU1vbnRoUmFuZ2Uge1xuICBjb25zdHJ1Y3RvcihvdmVycmlkZSByZWFkb25seSBmcm9tOiBQcml6bURheSwgb3ZlcnJpZGUgcmVhZG9ubHkgdG86IFByaXptRGF5KSB7XG4gICAgc3VwZXIoZnJvbSwgdG8pO1xuXG4gICAgaWYgKGZyb20gJiYgdG8pIHByaXptQXNzZXJ0LmFzc2VydChmcm9tLmRheVNhbWVPckJlZm9yZSh0bykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgcmFuZ2UgZnJvbSB0d28gZGF5cyBhZnRlciBzb3J0aW5nIHRoZW1cbiAgICpcbiAgICogQHBhcmFtIGRheTFcbiAgICogQHBhcmFtIGRheTJcbiAgICogQHJldHVybiBuZXcgcmFuZ2Ugd2l0aCBzb3J0ZWQgZGF5c1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBvdmVycmlkZSBzb3J0KGRheTE6IFByaXptRGF5LCBkYXkyOiBQcml6bURheSk6IFByaXptRGF5UmFuZ2Uge1xuICAgIHJldHVybiBkYXkxLmRheVNhbWVPckJlZm9yZShkYXkyKSA/IG5ldyBQcml6bURheVJhbmdlKGRheTEsIGRheTIpIDogbmV3IFByaXptRGF5UmFuZ2UoZGF5MiwgZGF5MSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21Mb2NhbE5hdGl2ZURhdGUoZGF0ZTE6IERhdGUsIGRhdGUyOiBEYXRlKTogUHJpem1EYXlSYW5nZSB7XG4gICAgcmV0dXJuIG5ldyBQcml6bURheVJhbmdlKFByaXptRGF5LmZyb21Mb2NhbE5hdGl2ZURhdGUoZGF0ZTEpLCBQcml6bURheS5mcm9tTG9jYWxOYXRpdmVEYXRlKGRhdGUyKSk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbm9ybWFsaXplUGFyc2UoXG4gICAgcmFuZ2VTdHJpbmc6IHN0cmluZyxcbiAgICBkYXRlRmlsbGVyOiBzdHJpbmcsXG4gICAgZGF0ZVJhbmdlRmlsbGVyOiBzdHJpbmdcbiAgKTogUHJpem1EYXlSYW5nZTtcbiAgcHVibGljIHN0YXRpYyBub3JtYWxpemVQYXJzZShyYW5nZVN0cmluZzogc3RyaW5nLCBkYXRlTW9kZT86IFByaXptRGF0ZU1vZGUpOiBQcml6bURheVJhbmdlO1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhbmQgY29ycmVjdCBhIGRheSByYW5nZSBpbiBzdHJpbmcgZm9ybWF0XG4gICAqXG4gICAqIEBwYXJhbSByYW5nZVN0cmluZyBhIHN0cmluZyBvZiBkYXRlcyBpbiBhIGZvcm1hdCBkZC5tbS55eXl5IC0gZGQubW0ueXl5eVxuICAgKiBAcGFyYW0gZGF0ZU1vZGUge0BsaW5rIFByaXptRGF0ZU1vZGV9XG4gICAqIEByZXR1cm4gbm9ybWFsaXplZCBkYXkgcmFuZ2Ugb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG5vcm1hbGl6ZVBhcnNlKHJhbmdlU3RyaW5nOiBzdHJpbmcsIGRhdGVNb2RlOiBzdHJpbmcgfCBQcml6bURhdGVNb2RlID0gYERNWWApOiBQcml6bURheVJhbmdlIHtcbiAgICBjb25zdCBkYXRlRm9ybWF0ID0gcHJpem1Jc0RhdGVNb2RlKGRhdGVNb2RlKSA/IGRhdGVNb2RlIDogYERNWWA7XG5cbiAgICBjb25zdCBsZWZ0RGF5ID0gUHJpem1EYXkubm9ybWFsaXplUGFyc2UocmFuZ2VTdHJpbmcuc2xpY2UoMCwgUFJJWk1fREFURV9GSUxMRVJfTEVOR1RIKSwgZGF0ZUZvcm1hdCk7XG5cbiAgICBpZiAocmFuZ2VTdHJpbmcubGVuZ3RoIDwgUFJJWk1fREFURV9SQU5HRV9GSUxMRVJfTEVOR1RIKSB7XG4gICAgICByZXR1cm4gbmV3IFByaXptRGF5UmFuZ2UobGVmdERheSwgbGVmdERheSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByaXptRGF5UmFuZ2Uuc29ydChcbiAgICAgIGxlZnREYXksXG4gICAgICBQcml6bURheS5ub3JtYWxpemVQYXJzZShcbiAgICAgICAgcmFuZ2VTdHJpbmcuc2xpY2UoUFJJWk1fREFURV9GSUxMRVJfTEVOR1RIICsgUFJJWk1fUkFOR0VfU0VQQVJBVE9SX0NIQVIubGVuZ3RoKSxcbiAgICAgICAgZGF0ZUZvcm1hdFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBnZXQgaXNTaW5nbGVEYXkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbS5kYXlTYW1lKHRoaXMudG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEh1bWFuIHJlYWRhYmxlIGZvcm1hdC5cbiAgICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBnZXRGb3JtYXR0ZWREYXlSYW5nZX0gaW5zdGVhZFxuICAgKi9cbiAgcHVibGljIGdldCBmb3JtYXR0ZWREYXlSYW5nZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb20uZ2V0Rm9ybWF0dGVkRGF5KGBETVlgLCBgLmApO1xuICAgIGNvbnN0IHRvID0gdGhpcy50by5nZXRGb3JtYXR0ZWREYXkoYERNWWAsIGAuYCk7XG5cbiAgICByZXR1cm4gYCR7ZnJvbX0ke1BSSVpNX1JBTkdFX1NFUEFSQVRPUl9DSEFSfSR7dG99YDtcbiAgfVxuXG4gIHB1YmxpYyBpc0RheUluUmFuZ2UoZGF5OiBQcml6bURheSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBkYXkuZGF5U2FtZU9yQWZ0ZXIodGhpcy5mcm9tKSAmJiBkYXkuZGF5U2FtZU9yQmVmb3JlKHRoaXMudG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIHJhbmdlcyBmb3IgaWRlbnRpdHlcbiAgICpcbiAgICogQHBhcmFtIGFub3RoZXIgc2Vjb25kIHJhbmdlIHRvIHRlc3QgYWdhaW5zdCBjdXJyZW50XG4gICAqIEByZXR1cm4gYHRydWVgIGlmIGRheXMgYXJlIGlkZW50aWNhbFxuICAgKi9cbiAgcHVibGljIGRheVNhbWUoYW5vdGhlcjogUHJpem1EYXlSYW5nZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmZyb20uZGF5U2FtZShhbm90aGVyLmZyb20pICYmIHRoaXMudG8uZGF5U2FtZShhbm90aGVyLnRvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrcyByYW5nZSBiZXR3ZWVuIHR3byBkYXlzIGluY2x1ZGVkLCBvciBsaW1pdHMgZnJvbSBvbmUgc2lkZSBpZiB0aGUgb3RoZXIgaXMgbnVsbFxuICAgKlxuICAgKiBAcGFyYW0gbWluXG4gICAqIEBwYXJhbSBtYXhcbiAgICogQHJldHVybiByYW5nZSDigJQgY2xhbXBlZCByYW5nZVxuICAgKi9cbiAgcHVibGljIGRheUxpbWl0KG1pbjogUHJpem1EYXkgfCBudWxsLCBtYXg6IFByaXptRGF5IHwgbnVsbCk6IFByaXptRGF5UmFuZ2Uge1xuICAgIHJldHVybiBuZXcgUHJpem1EYXlSYW5nZSh0aGlzLmZyb20uZGF5TGltaXQobWluLCBtYXgpLCB0aGlzLnRvLmRheUxpbWl0KG1pbiwgbWF4KSk7XG4gIH1cblxuICAvKipcbiAgICogSHVtYW4gcmVhZGFibGUgZm9ybWF0LlxuICAgKi9cbiAgcHVibGljIGdldEZvcm1hdHRlZERheVJhbmdlKGRhdGVGb3JtYXQ6IFByaXptRGF0ZU1vZGUsIGRhdGVTZXBhcmF0b3I6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbS5nZXRGb3JtYXR0ZWREYXkoZGF0ZUZvcm1hdCwgZGF0ZVNlcGFyYXRvcik7XG4gICAgY29uc3QgdG8gPSB0aGlzLnRvPy5nZXRGb3JtYXR0ZWREYXkoZGF0ZUZvcm1hdCwgZGF0ZVNlcGFyYXRvcikgPz8gJyc7XG5cbiAgICByZXR1cm4gYCR7ZnJvbX0ke1BSSVpNX1JBTkdFX1NFUEFSQVRPUl9DSEFSfSR7dG99YDtcbiAgfVxuXG4gIHB1YmxpYyB0b0xvY2FsTmF0aXZlRGF0ZSgpOiBbRGF0ZSB8IG51bGwsIERhdGUgfCBudWxsXSB7XG4gICAgcmV0dXJuIFt0aGlzLmZyb20/LnRvTG9jYWxOYXRpdmVEYXRlKCkgPz8gbnVsbCwgdGhpcy50bz8udG9Mb2NhbE5hdGl2ZURhdGUoKSA/PyBudWxsXTtcbiAgfVxuXG4gIHB1YmxpYyBvdmVycmlkZSB0b1N0cmluZyhkYXRlRm9ybWF0OiBQcml6bURhdGVNb2RlID0gYERNWWAsIGRhdGVTZXBhcmF0b3IgPSBgLmApOiBzdHJpbmcge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLmZyb20uZ2V0Rm9ybWF0dGVkRGF5KGRhdGVGb3JtYXQsIGRhdGVTZXBhcmF0b3IpO1xuICAgIGNvbnN0IHRvID0gdGhpcy50bz8uZ2V0Rm9ybWF0dGVkRGF5KGRhdGVGb3JtYXQsIGRhdGVTZXBhcmF0b3IpID8/ICcnO1xuXG4gICAgcmV0dXJuIGAke2Zyb219JHtQUklaTV9SQU5HRV9TRVBBUkFUT1JfQ0hBUn0ke3RvfWA7XG4gIH1cbn1cbiJdfQ==